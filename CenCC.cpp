#include "CenCC.h"


void buildCV(const Mat& lImg, const Mat& rImg, const int maxDis, Mat* costVol)
{
	// for TAD + Grd input image must be CV_64FC3
	CV_Assert(lImg.type() == CV_64FC3 && rImg.type() == CV_64FC3);

	int hei = lImg.rows;
	int wid = lImg.cols;
	Mat lGray, rGray;
	Mat tmp;
	lImg.convertTo(tmp, CV_32F);
	cvtColor(tmp, lGray, CV_RGB2GRAY);
	lGray.convertTo(lGray, CV_8U, 255);
	rImg.convertTo(tmp, CV_32F);
	cvtColor(tmp, rGray, CV_RGB2GRAY);
	rGray.convertTo(rGray, CV_8U, 255);
	// prepare binary code 
	int H_WD = CENCUS_WND / 2;
	bitset<CENCUS_BIT>* lCode = new bitset<CENCUS_BIT>[wid * hei];
	bitset<CENCUS_BIT>* rCode = new bitset<CENCUS_BIT>[wid * hei];
	bitset<CENCUS_BIT>* pLCode = lCode;
	bitset<CENCUS_BIT>* pRCode = rCode;
	for (int y = 0; y < hei; y++) {
		uchar* pLData = (uchar*)(lGray.ptr<uchar>(y));
		uchar* pRData = (uchar*)(rGray.ptr<uchar>(y));
		for (int x = 0; x < wid; x++) {
			int bitCnt = 0;
			for (int wy = -H_WD; wy <= H_WD; wy++) {
				int qy = (y + wy + hei) % hei;
				uchar* qLData = (uchar*)(lGray.ptr<uchar>(qy));
				uchar* qRData = (uchar*)(rGray.ptr<uchar>(qy));
				for (int wx = -H_WD; wx <= H_WD; wx++) {
					if (wy != 0 || wx != 0) {
						int qx = (x + wx + wid) % wid;
						(*pLCode)[bitCnt] = (pLData[x] > qLData[qx]);
						(*pRCode)[bitCnt] = (pRData[x] > qRData[qx]);
						bitCnt++;
					}

				}
			}
			pLCode++;
			pRCode++;
		}
	}
	// build cost volume
	bitset<CENCUS_BIT> lB;
	bitset<CENCUS_BIT> rB;
	pLCode = lCode;
	for (int y = 0; y < hei; y++) {
		int index = y * wid;
		for (int x = 0; x < wid; x++) {
			lB = *pLCode;
			for (int d = 0; d < maxDis; d++) {
				double* cost = (double*)costVol[d].ptr<double>(y);
				cost[x] = CENCUS_BIT;
				if (x - d >= 0) {
					rB = rCode[index + x - d];
					cost[x] = (lB ^ rB).count();
				}

			}
			pLCode++;
		}
	}
	delete[] lCode;
	delete[] rCode;
}

void buildRightCV(const Mat& lImg, const Mat& rImg, const int maxDis, Mat* rCostVol)
{
	// for TAD + Grd input image must be CV_64FC3
	CV_Assert(lImg.type() == CV_64FC3 && rImg.type() == CV_64FC3);

	int hei = lImg.rows;
	int wid = lImg.cols;
	Mat lGray, rGray;
	Mat tmp;
	lImg.convertTo(tmp, CV_32F);
	cvtColor(tmp, lGray, CV_RGB2GRAY);
	lGray.convertTo(lGray, CV_8U, 255);
	rImg.convertTo(tmp, CV_32F);
	cvtColor(tmp, rGray, CV_RGB2GRAY);
	rGray.convertTo(rGray, CV_8U, 255);
	// prepare binary code 
	int H_WD = CENCUS_WND / 2;
	bitset<CENCUS_BIT>* lCode = new bitset<CENCUS_BIT>[wid * hei];
	bitset<CENCUS_BIT>* rCode = new bitset<CENCUS_BIT>[wid * hei];
	bitset<CENCUS_BIT>* pLCode = lCode;
	bitset<CENCUS_BIT>* pRCode = rCode;
	for (int y = 0; y < hei; y++) {
		uchar* pLData = (uchar*)(lGray.ptr<uchar>(y));
		uchar* pRData = (uchar*)(rGray.ptr<uchar>(y));
		for (int x = 0; x < wid; x++) {
			int bitCnt = 0;
			for (int wy = -H_WD; wy <= H_WD; wy++) {
				int qy = (y + wy + hei) % hei;
				uchar* qLData = (uchar*)(lGray.ptr<uchar>(qy));
				uchar* qRData = (uchar*)(rGray.ptr<uchar>(qy));
				for (int wx = -H_WD; wx <= H_WD; wx++) {
					if (wy != 0 || wx != 0) {
						int qx = (x + wx + wid) % wid;
						(*pLCode)[bitCnt] = (pLData[x] > qLData[qx]);
						(*pRCode)[bitCnt] = (pRData[x] > qRData[qx]);
						bitCnt++;
					}

				}
			}
			pLCode++;
			pRCode++;
		}
	}
	// build cost volume
	bitset<CENCUS_BIT> lB;
	bitset<CENCUS_BIT> rB;
	pRCode = rCode;
	for (int y = 0; y < hei; y++) {
		int index = y * wid;
		for (int x = 0; x < wid; x++) {
			rB = *pRCode;
			for (int d = 0; d < maxDis; d++) {
				double* cost = (double*)rCostVol[d].ptr<double>(y);
				cost[x] = CENCUS_BIT;
				if (x + d < wid) {
					lB = lCode[index + x + d];
					cost[x] = (rB ^ lB).count();
				}

			}
			pRCode++;
		}
	}
	delete[] lCode;
	delete[] rCode;
}
